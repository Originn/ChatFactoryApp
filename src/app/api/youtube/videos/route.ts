import { NextRequest, NextResponse } from 'next/server';
import { getValidAccessToken } from '@/lib/youtube/oauth-utils';
import { YouTubeVideo } from '@/types/youtube';

/**
 * Format ISO 8601 duration to readable format
 */
function formatDuration(duration: string): string {
  const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
  if (!match) return '0:00';

  const hours = parseInt(match[1]?.replace('H', '') || '0');
  const minutes = parseInt(match[2]?.replace('M', '') || '0');
  const seconds = parseInt(match[3]?.replace('S', '') || '0');

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
  
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const userId = searchParams.get('userId');
    const maxResults = parseInt(searchParams.get('maxResults') || '25');
    const pageToken = searchParams.get('pageToken');
    const searchQuery = searchParams.get('searchQuery');

    if (!userId) {
      return NextResponse.json(
        { error: 'Missing userId parameter' },
        { status: 400 }
      );
    }

    // Get valid access token (auto-refreshes if needed)
    const accessToken = await getValidAccessToken(userId);
    const apiKey = process.env.YOUTUBE_API_KEY;

    if (!apiKey) {
      throw new Error('YouTube API key not configured');
    }

    // First get the channel's upload playlist (like the working version)
    const channelResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/channels?part=contentDetails&mine=true&key=${apiKey}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!channelResponse.ok) {
      throw new Error('Failed to fetch channel details');
    }

    const channelData = await channelResponse.json();
    const uploadsPlaylistId = channelData.items[0]?.contentDetails?.relatedPlaylists?.uploads;

    if (!uploadsPlaylistId) {
      return NextResponse.json({ 
        videos: [], 
        totalResults: 0,
        nextPageToken: null
      });
    }

    // Fetch videos from uploads playlist
    const params = new URLSearchParams({
      part: 'snippet,contentDetails',
      playlistId: uploadsPlaylistId,
      maxResults: maxResults.toString(),
      key: apiKey
    });

    if (pageToken) {
      params.append('pageToken', pageToken);
    }

    const videosResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/playlistItems?${params.toString()}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!videosResponse.ok) {
      throw new Error('Failed to fetch videos');
    }

    const videosData = await videosResponse.json();

    // Get detailed video information (including privacy status)
    const videoIds = videosData.items.map((item: any) => item.snippet.resourceId.videoId).join(',');
    
    if (!videoIds) {
      return NextResponse.json({ 
        videos: [], 
        totalResults: 0,
        nextPageToken: null
      });
    }

    const videoDetailsResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics,status&id=${videoIds}&key=${apiKey}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!videoDetailsResponse.ok) {
      throw new Error('Failed to fetch video details');
    }

    const videoDetailsData = await videoDetailsResponse.json();

    // Get caption information for all videos
    const captionVideoIds = videoDetailsData.items.map((item: any) => item.id).join(',');
    let captionsData: any = { items: [] };
    
    if (captionVideoIds) {
      try {
        const captionsResponse = await fetch(
          `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${captionVideoIds}&key=${apiKey}`,
          {
            headers: {
              'Authorization': `Bearer ${accessToken}`
            }
          }
        );
        
        if (captionsResponse.ok) {
          captionsData = await captionsResponse.json();
        }
      } catch (error) {
        console.warn('Failed to fetch caption data:', error);
      }
    }

    // Group captions by video ID
    const captionsByVideo = new Map();
    if (captionsData.items) {
      captionsData.items.forEach((caption: any) => {
        const videoId = caption.snippet.videoId;
        if (!captionsByVideo.has(videoId)) {
          captionsByVideo.set(videoId, []);
        }
        captionsByVideo.get(videoId).push({
          language: caption.snippet.language,
          languageName: caption.snippet.name,
          isAutoGenerated: caption.snippet.trackKind === 'ASR'
        });
      });
    }

    // Transform the data to match the previous working format
    const videos: YouTubeVideo[] = videoDetailsData.items.map((video: any) => ({
      id: video.id,
      title: video.snippet.title,
      description: video.snippet.description,
      thumbnailUrl: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default.url,
      duration: formatDuration(video.contentDetails.duration),
      publishedAt: video.snippet.publishedAt,
      channelTitle: video.snippet.channelTitle,
      viewCount: video.statistics?.viewCount,
      privacy: video.status.privacyStatus === 'public' ? 'public' : 
               video.status.privacyStatus === 'unlisted' ? 'unlisted' : 'private',
      transcripts: captionsByVideo.get(video.id) || []
    }));

    // Filter by search query if provided (like the working version)
    const filteredVideos = searchQuery 
      ? videos.filter(video => 
          video.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
          video.description.toLowerCase().includes(searchQuery.toLowerCase())
        )
      : videos;

    // Update last used timestamp (like the working version)
    await getValidAccessToken(userId); // This handles the timestamp update

    return NextResponse.json({
      videos: filteredVideos,
      nextPageToken: videosData.nextPageToken,
      totalResults: videosData.pageInfo?.totalResults || 0
    });

  } catch (error) {
    console.error('Error fetching YouTube videos:', error);
    
    if (error instanceof Error && error.message.includes('not connected')) {
      return NextResponse.json(
        { error: 'YouTube account not connected' },
        { status: 404 }
      );
    }
    
    if (error instanceof Error && error.message.includes('refresh failed')) {
      return NextResponse.json(
        { error: 'Authentication expired', requiresReauth: true },
        { status: 401 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to fetch videos' },
      { status: 500 }
    );
  }
}